 {Project: EE-9 Platform: Parallax Project USB Board Revision: 1.1 Author: Dillon Chew Date: 28 Nov 2021 Log:   Date: Desc   26/11/2021: Fixed the core not running repeatedly   28/11/2021: Modified the MotorCore file to make it not run on PWM}CON        _clkmode = xtal1 + pll16x           'Standard clock mode * crystal frequency = 80 MHz        _xinfreq = 5_000_000        'creating a pause()        _ConClkFreq = ((_clkmode - xtal1 >> 6) * _xinfreq)        '_Ms_001 = _ConClkFreq / 1_000        'declare pins for motor        motor1 = 10        motor2 = 11        motor3 = 12        motor4 = 13        'setting each motor too stationary        motor1Zero = 1470        motor2Zero = 1470        motor3Zero = 1460        motor4Zero = 1460VAR 'global variable  long motorCoreStack[64]  long cog2ID  long _Ms_001OBJ  Motors      : "Servo8Fast_vZ2.spin"  Term        : "FullDuplexSerial.spin"PUB Start (mainMSVal,control,speed)  _Ms_001:=mainMSVal  StopCore  cog2ID:=cognew(MotorCore(control,speed),@motorCoreStack)   'initialise a new core  returnPUB Init          'initialise all motors  Motors.Init  Motors.AddSlowPin(motor1)  Motors.AddSlowPin(motor2)  Motors.AddSlowPin(motor3)  Motors.AddSlowPin(motor4)  Motors.Start  Pause(100)PUB StopCore      'stop running core  if cog2ID    cogstop(cog2ID~)PUB MotorCore(control,speed)  Init  StopAllMotorsrepeat  case long[control]   'make motors move in forward direction    1:          Motors.Set(motor1, motor1Zero+long[speed])          Motors.Set(motor2, motor2Zero+long[speed])          Motors.Set(motor3, motor3Zero+long[speed])          Motors.Set(motor4, motor4Zero+long[speed])          Pause(50)    2:   'make motors move in reverse direction          Motors.Set(motor1, motor1Zero-long[speed])          Motors.Set(motor2, motor2Zero-long[speed])          Motors.Set(motor3, motor3Zero-long[speed])          Motors.Set(motor4, motor4Zero-long[speed])          Pause(50)    3:     'make motors turn left          Motors.Set(motor1, motor1Zero+long[speed])          Motors.Set(motor2, motor2Zero-long[speed])          Motors.Set(motor3, motor3Zero+long[speed])          Motors.Set(motor4, motor4Zero-long[speed])          Pause(50)          Pause(300)    4:     'make motors turn right          Motors.Set(motor1, motor1Zero-long[speed])          Motors.Set(motor2, motor2Zero+long[speed])          Motors.Set(motor3, motor3Zero-long[speed])          Motors.Set(motor4, motor4Zero+long[speed])          Pause(50)        Pause(300)    5:       'stop all motors      Motors.Set(motor1, motor1Zero)      Motors.Set(motor2, motor2Zero)      Motors.Set(motor3, motor3Zero)      Motors.Set(motor4, motor4Zero)PRI StopAllMotors    'set motor speed to 0 to stop all motors  Motors.Set(motor1, motor1Zero)  Motors.Set(motor2, motor2Zero)  Motors.Set(motor3, motor3Zero)  Motors.Set(motor4, motor4Zero)PRI Pause (ms) | t  t := cnt - 1088  repeat (ms#>0)    waitcnt (t+=_Ms_001)  returnDATname    byte  "string_data",0